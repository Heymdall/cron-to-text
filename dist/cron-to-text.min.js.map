{"version":3,"sources":["/source/cron-to-text.js","/source/src/parseCron.js","cron-to-text.min.js","/source/src/cron-to-text.js"],"names":["global","factory","exports","module","define","amd","cronToText","this","getValue","value","offset","arguments","length","undefined","max","isNaN","NAMES","Math","min","cloneSchedule","sched","field","clone","slice","add","name","inc","i","indexOf","push","sort","a","b","addHash","schedules","curSched","hash","d","dc","addWeekday","s","except1","except2","MON","FRI","TUE","THU","exceptions","addRange","item","incSplit","split","range","rangeSplit","parse","toString","replace","isHash","itemSorter","parseExpr","expr","f","component","items","schedule","components","FIELDS","prepareExpr","prepared","toUpperCase","REPLACEMENTS","parseCron","hasSeconds","e","cronspec","sixth","absFloor","number","ceil","floor","toInt","argumentForCoercion","coercedNumber","isFinite","ordinal","output","locale","ORDINALS","th","st","nd","rd","numberList","numbers","lastVal","pop","join","numberToDateName","type","DOW","MONTH","dateList","outputText","zeroPad","x","scheduleToSentence","Every","hm","j","and","LOCALE","JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC","SUN","WED","SAT","* * * * * *","@YEARLY","@ANNUALLY","@MONTHLY","@WEEKLY","@DAILY","@HOURLY","m","h","D","M","Y","every day","minute past the","hour","minute","minute of","minute every hour","on the","of every month","and every","on","in","cron_to_text"],"mappings":"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","file":"cron-to-text.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.cronToText = factory()\n}(this, function () { 'use strict';\n\n  // Constant array to convert valid names to values\n  const NAMES = {\n    JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8,\n    SEP: 9, OCT: 10, NOV: 11, DEC: 12,\n    SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7\n  };\n\n  // Parsable replacements for common expressions\n  const REPLACEMENTS = {\n    '* * * * * *': '0/1 * * * * *',\n    '@YEARLY': '0 0 1 1 *',\n    '@ANNUALLY': '0 0 1 1 *',\n    '@MONTHLY': '0 0 1 * *',\n    '@WEEKLY': '0 0 * * 0',\n    '@DAILY': '0 0 * * *',\n    '@HOURLY': '0 * * * *'\n  };\n\n  // Contains the index, min, and max for each of the constraints\n  const FIELDS = {\n    s: [0, 0, 59],      // seconds\n    m: [1, 0, 59],      // minutes\n    h: [2, 0, 23],      // hours\n    D: [3, 1, 31],      // day of month\n    M: [4, 1, 12],      // month\n    Y: [6, 1970, 2099], // year\n    d: [5, 1, 7, 1]     // day of week\n  };\n\n  /**\n   * Returns the value + offset if value is a number, otherwise it\n   * attempts to look up the value in the NAMES table and returns\n   * that result instead.\n   *\n   * @param {Number,String} value: The value that should be parsed\n   * @param {Number=} offset: Any offset that must be added to the value\n   * @param {Number=} max\n   * @returns {Number|null}\n   */\n  function getValue(value, offset = 0, max = 9999) {\n    return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset), max);\n  }\n\n  /**\n   * Returns a deep clone of a schedule skipping any day of week\n   * constraints.\n   *\n   * @param {Object} sched: The schedule that will be cloned\n   * @returns {Object}\n   */\n  function cloneSchedule(sched) {\n    var clone = {}, field;\n\n    for (field in sched) {\n      if (field !== 'dc' && field !== 'd') {\n        clone[field] = sched[field].slice(0);\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n   * Adds values to the specified constraint in the current schedule.\n   *\n   * @param {Object} sched: The schedule to add the constraint to\n   * @param {String} name: Name of constraint to add\n   * @param {Number} min: Minimum value for this constraint\n   * @param {Number} max: Maximum value for this constraint\n   * @param {Number=} inc: The increment to use between min and max\n   */\n  function add(sched, name, min, max, inc = 0) {\n    var i = min;\n\n    if (!sched[name]) {\n      sched[name] = [];\n    }\n\n    while (i <= max) {\n      if (sched[name].indexOf(i) < 0) {\n        sched[name].push(i);\n      }\n      i += inc || 1;\n    }\n\n    sched[name].sort(function (a, b) {\n      return a - b;\n    });\n  }\n\n  /**\n   * Adds a hash item (of the form x#y or xL) to the schedule.\n   *\n   * @param {Object} schedules: The current schedule array to add to\n   * @param {Object} curSched: The current schedule to add to\n   * @param {Number} value: The value to add (x of x#y or xL)\n   * @param {Number} hash: The hash value to add (y of x#y)\n   */\n  function addHash(schedules, curSched, value, hash) {\n    // if there are any existing day of week constraints that\n    // aren't equal to the one we're adding, create a new\n    // composite schedule\n    if ((curSched.d && !curSched.dc) ||\n      (curSched.dc && curSched.dc.indexOf(hash) < 0)) {\n      schedules.push(cloneSchedule(curSched));\n      curSched = schedules[schedules.length - 1];\n    }\n\n    add(curSched, 'd', value, value);\n    add(curSched, 'dc', hash, hash);\n  }\n\n  /**\n   *\n   * @param {Object} s: The existing set of schedules\n   * @param {Object} curSched: The current schedule to add to\n   * @param {Number} value\n   */\n  function addWeekday(s, curSched, value) {\n    var except1 = {}, except2 = {};\n    if (value === 1) {\n      // cron doesn't pass month boundaries, so if 1st is a\n      // weekend then we need to use 2nd or 3rd instead\n      add(curSched, 'D', 1, 3);\n      add(curSched, 'd', NAMES.MON, NAMES.FRI);\n      add(except1, 'D', 2, 2);\n      add(except1, 'd', NAMES.TUE, NAMES.FRI);\n      add(except2, 'D', 3, 3);\n      add(except2, 'd', NAMES.TUE, NAMES.FRI);\n    } else {\n      // normally you want the closest day, so if v is a\n      // Saturday, use the previous Friday.  If it's a\n      // sunday, use the following Monday.\n      add(curSched, 'D', value - 1, value + 1);\n      add(curSched, 'd', NAMES.MON, NAMES.FRI);\n      add(except1, 'D', value - 1, value - 1);\n      add(except1, 'd', NAMES.MON, NAMES.THU);\n      add(except2, 'D', value + 1, value + 1);\n      add(except2, 'd', NAMES.TUE, NAMES.FRI);\n    }\n    s.exceptions.push(except1);\n    s.exceptions.push(except2);\n  }\n\n  /**\n   * Adds a range item (of the form x-y/z) to the schedule.\n   *\n   * @param {String} item: The cron expression item to add\n   * @param {Object} curSched: The current schedule to add to\n   * @param {String} name: The name to use for this constraint\n   * @param {Number} min: The min value for the constraint\n   * @param {Number} max: The max value for the constraint\n   * @param {Number} offset: The offset to apply to the cron value\n   */\n  function addRange(item, curSched, name, min, max, offset) {\n    // parse range/x\n    var incSplit = item.split('/'),\n      inc = +incSplit[1],\n      range = incSplit[0];\n\n    // parse x-y or * or 0\n    if (range !== '*' && range !== '0') {\n      var rangeSplit = range.split('-');\n      min = getValue(rangeSplit[0], offset, max);\n\n      // fix for issue #13, range may be single digit\n      max = getValue(rangeSplit[1], offset, max) || max;\n    }\n\n    add(curSched, name, min, max, inc);\n  }\n\n  /**\n   * Parses a particular item within a cron expression.\n   *\n   * @param {String} item: The cron expression item to parse\n   * @param {Object} s: The existing set of schedules\n   * @param {String} name: The name to use for this constraint\n   * @param {Number} min: The min value for the constraint\n   * @param {Number} max: The max value for the constraint\n   * @param {Number} offset: The offset to apply to the cron value\n   */\n  function parse(item, s, name, min, max, offset) {\n    var value,\n      split,\n      schedules = s.schedules,\n      curSched = schedules[schedules.length - 1];\n\n    // L just means min - 1 (this also makes it work for any field)\n    if (item === 'L') {\n      item = (min - 1).toString(10);\n    }\n\n    // parse x\n    if ((value = getValue(item, offset, max)) !== null) {\n      add(curSched, name, value, value);\n    }\n    // parse xW\n    else if ((value = getValue(item.replace('W', ''), offset, max)) !== null) {\n      addWeekday(s, curSched, value);\n    }\n    // parse xL\n    else if ((value = getValue(item.replace('L', ''), offset, max)) !== null) {\n      addHash(schedules, curSched, value, min - 1);\n    }\n    // parse x#y\n    else if ((split = item.split('#')).length === 2) {\n      value = getValue(split[0], offset, max);\n      addHash(schedules, curSched, value, getValue(split[1]));\n    }\n    // parse x-y or x-y/z or */z or 0/z\n    else {\n      addRange(item, curSched, name, min, max, offset);\n    }\n  }\n\n  /**\n   * Returns true if the item is either of the form x#y or xL.\n   *\n   * @param {String} item: The expression item to check\n   */\n  function isHash(item) {\n    return item.indexOf('#') > -1 || item.indexOf('L') > 0;\n  }\n\n\n  function itemSorter(a, b) {\n    return isHash(a) && !isHash(b) ? 1 : a - b;\n  }\n\n  /**\n   * Parses each of the fields in a cron expression.  The expression must\n   * include the seconds field, the year field is optional.\n   *\n   * @param {String} expr: The cron expression to parse\n   */\n  function parseExpr(expr) {\n    var schedule = {schedules: [{}], exceptions: []},\n      components = expr.replace(/(\\s)+/g, ' ').split(' '),\n      field, f, component, items;\n\n    for (field in FIELDS) {\n      f = FIELDS[field];\n      component = components[f[0]];\n      if (component && component !== '*' && component !== '?') {\n        // need to sort so that any #'s come last, otherwise\n        // schedule clones to handle # won't contain all of the\n        // other constraints\n        items = component.split(',').sort(itemSorter);\n        var i, length = items.length;\n        for (i = 0; i < length; i++) {\n          parse(items[i], schedule, field, f[1], f[2], f[3]);\n        }\n      }\n    }\n\n    return schedule;\n  }\n\n  /**\n   * Make cron expression parsable.\n   *\n   * @param {String} expr: The cron expression to prepare\n   */\n  function prepareExpr(expr) {\n    var prepared = expr.toUpperCase();\n    return REPLACEMENTS[prepared] || prepared;\n  }\n\n  function parseCron(expr, hasSeconds) {\n    var e = prepareExpr(expr);\n    return parseExpr(hasSeconds ? e : '0 ' + e);\n  }\n\n  const LOCALE = {\n    ORDINALS: {\n      th: 'th',\n      st: 'st',\n      nd: 'nd',\n      rd: 'rd'\n    },\n    MONTH: [\n      'Jan',\n      'Feb',\n      'Mar',\n      'Apr',\n      'May',\n      'Jun',\n      'Jul',\n      'Aug',\n      'Sep',\n      'Oct',\n      'Nov',\n      'Dec'\n    ],\n    DOW: [\n      'Sun',\n      'Mon',\n      'Tue',\n      'Wed',\n      'Thu',\n      'Fri',\n      'Sat'\n    ],\n    'Every': 'Every', // start of expression\n    'and': 'and', // 1, 2, 3 and 15th\n    'every day': 'every day',\n    'minute past the': 'minute past the',\n    'hour': 'hour',\n    'minute': 'minute',\n    'minute of': 'minute of',\n    'minute every hour': 'minute every hour',\n    'on the': 'on the',\n    'of every month': 'of every month',\n    'and every': 'and every',\n    'on': 'on', // on sun, mon\n    'in': 'in' // in jan, apr\n  };\n\n  /**\n   * Given a cronspec, return the human-readable string.\n   * @param {string} cronspec\n   * @param sixth\n   * @param {Object=} locale\n   */\n  function cronToText(cronspec, sixth, locale = LOCALE) {\n    var schedule = parseCron(cronspec, sixth);\n\n    function absFloor(number) {\n      if (number < 0) {\n        return Math.ceil(number);\n      } else {\n        return Math.floor(number);\n      }\n    }\n\n    function toInt(argumentForCoercion) {\n      var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n      if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n        value = absFloor(coercedNumber);\n      }\n\n      return value;\n    }\n\n    function ordinal(number) {\n      var b = number % 10,\n        output = (toInt(number % 100 / 10) === 1) ? locale.ORDINALS.th :\n          (b === 1) ? locale.ORDINALS.st :\n            (b === 2) ? locale.ORDINALS.nd :\n              (b === 3) ? locale.ORDINALS.rd : locale.ORDINALS.th;\n      return number + output;\n    }\n\n    /**\n     * For an array of numbers, e.g. a list of hours in a schedule,\n     * return a string listing out all of the values (complete with\n     * \"and\" plus ordinal text on the last item).\n     * @param {Number[]} numbers\n     * @returns {string}\n     */\n    function numberList(numbers) {\n      if (numbers.length < 2) {\n        return ordinal(numbers);\n      }\n\n      var lastVal = numbers.pop();\n      return numbers.join(', ') + ` ${locale['and']} ` + ordinal(lastVal);\n    }\n\n    /**\n     * Parse a number into day of week, or a month name;\n     * used in dateList below.\n     * @param {Number|String} value\n     * @param {String} type\n     * @returns {String}\n     */\n    function numberToDateName(value, type) {\n      if (type == 'dow') {\n        return locale.DOW[value - 1];\n      } else if (type == 'mon') {\n        return locale.MONTH[value - 1];\n      }\n    }\n\n    /**\n     * From an array of numbers corresponding to dates (given in type: either\n     * days of the week, or months), return a string listing all the values.\n     * @param {Number[]} numbers\n     * @param {String} type\n     * @returns {String}\n     */\n    function dateList(numbers, type) {\n      if (numbers.length < 2) {\n        return numberToDateName('' + numbers[0], type);\n      }\n\n      var lastVal = '' + numbers.pop();\n      var outputText = '';\n\n      for (var i = 0, value; value = numbers[i]; i++) {\n        if (outputText.length > 0) {\n          outputText += ', ';\n        }\n        outputText += numberToDateName(value, type);\n      }\n      return outputText + ` ${locale['and']} ` + numberToDateName(lastVal, type);\n    }\n\n    /**\n     * Pad to equivalent of sprintf('%02d').\n     * @param {Number} x\n     * @returns {string}\n     */\n    function zeroPad(x) {\n      return (x < 10) ? '0' + x : x;\n    }\n\n    //----------------\n\n    /**\n     * Given a schedule, generate a friendly sentence description.\n     * @param {Object} schedule\n     * @returns {string}\n     */\n    function scheduleToSentence(schedule) {\n      var outputText = locale.Every + ' ';\n\n      if (schedule['h'] && schedule['m'] && schedule['h'].length <= 2 && schedule['m'].length <= 2) {\n        // If there are only one or two specified values for\n        // hour or minute, print them in HH:MM format\n\n        var hm = [];\n        for (var i = 0; i < schedule['h'].length; i++) {\n          for (var j = 0; j < schedule['m'].length; j++) {\n            hm.push(zeroPad(schedule['h'][i]) + ':' + zeroPad(schedule['m'][j]));\n          }\n        }\n        if (hm.length < 2) {\n          outputText = hm[0];\n        } else {\n          var lastVal = hm.pop();\n          outputText = hm.join(', ') + ` ${locale.and} ` + lastVal;\n        }\n        if (!schedule['d'] && !schedule['D']) {\n          outputText += ` ${locale['every day']}`;\n        }\n      } else {\n        // Otherwise, list out every specified hour/minute value.\n\n        if (schedule['h']) { // runs only at specific hours\n          if (schedule['m']) { // and only at specific minutes\n            outputText += numberList(schedule['m']) + ` ${locale['minute past the']} ` + numberList(schedule['h']) + ` ${locale['hour']}`;\n          } else { // specific hours, but every minute\n            outputText += `${locale['minute of']} ` + numberList(schedule['h']) + ` ${locale['hour']}`;\n          }\n        } else if (schedule['m']) { // every hour, but specific minutes\n          outputText += numberList(schedule['m']) + ` ${locale['minute every hour']}`;\n        } else { // cronspec has \"*\" for both hour and minute\n          outputText += locale['minute'];\n        }\n      }\n\n      if (schedule['D']) { // runs only on specific day(s) of month\n        outputText += (locale['on the'] ? ` ${locale['on the']} ` : ' ') + numberList(schedule['D']);\n        if (!schedule['M']) {\n          outputText += ` ${locale['of every month']}`;\n        }\n      }\n\n      if (schedule['d']) { // runs only on specific day(s) of week\n        if (schedule['D']) {\n          // if both day fields are specified, cron uses both; superuser.com/a/348372\n          outputText += ` ${locale['and every']} `;\n        } else {\n          outputText += ` ${locale['on']} `;\n        }\n        outputText += dateList(schedule['d'], 'dow');\n      }\n\n      if (schedule['M']) {\n        // runs only in specific months; put this output last\n        outputText += ` ${locale['in']} ` + dateList(schedule['M'], 'mon');\n      }\n\n      return outputText;\n    }\n\n    return scheduleToSentence(schedule.schedules[0]);\n  }\n\n  var cron_to_text = cronToText;\n\n  return cron_to_text;\n\n}));\n","// Constant array to convert valid names to values\nconst NAMES = {\n  JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8,\n  SEP: 9, OCT: 10, NOV: 11, DEC: 12,\n  SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7\n};\n\n// Parsable replacements for common expressions\nconst REPLACEMENTS = {\n  '* * * * * *': '0/1 * * * * *',\n  '@YEARLY': '0 0 1 1 *',\n  '@ANNUALLY': '0 0 1 1 *',\n  '@MONTHLY': '0 0 1 * *',\n  '@WEEKLY': '0 0 * * 0',\n  '@DAILY': '0 0 * * *',\n  '@HOURLY': '0 * * * *'\n};\n\n// Contains the index, min, and max for each of the constraints\nconst FIELDS = {\n  s: [0, 0, 59],      // seconds\n  m: [1, 0, 59],      // minutes\n  h: [2, 0, 23],      // hours\n  D: [3, 1, 31],      // day of month\n  M: [4, 1, 12],      // month\n  Y: [6, 1970, 2099], // year\n  d: [5, 1, 7, 1]     // day of week\n};\n\n/**\n * Returns the value + offset if value is a number, otherwise it\n * attempts to look up the value in the NAMES table and returns\n * that result instead.\n *\n * @param {Number,String} value: The value that should be parsed\n * @param {Number=} offset: Any offset that must be added to the value\n * @param {Number=} max\n * @returns {Number|null}\n */\nfunction getValue(value, offset = 0, max = 9999) {\n  return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset), max);\n}\n\n/**\n * Returns a deep clone of a schedule skipping any day of week\n * constraints.\n *\n * @param {Object} sched: The schedule that will be cloned\n * @returns {Object}\n */\nfunction cloneSchedule(sched) {\n  var clone = {}, field;\n\n  for (field in sched) {\n    if (field !== 'dc' && field !== 'd') {\n      clone[field] = sched[field].slice(0);\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Adds values to the specified constraint in the current schedule.\n *\n * @param {Object} sched: The schedule to add the constraint to\n * @param {String} name: Name of constraint to add\n * @param {Number} min: Minimum value for this constraint\n * @param {Number} max: Maximum value for this constraint\n * @param {Number=} inc: The increment to use between min and max\n */\nfunction add(sched, name, min, max, inc = 0) {\n  var i = min;\n\n  if (!sched[name]) {\n    sched[name] = [];\n  }\n\n  while (i <= max) {\n    if (sched[name].indexOf(i) < 0) {\n      sched[name].push(i);\n    }\n    i += inc || 1;\n  }\n\n  sched[name].sort(function (a, b) {\n    return a - b;\n  });\n}\n\n/**\n * Adds a hash item (of the form x#y or xL) to the schedule.\n *\n * @param {Object} schedules: The current schedule array to add to\n * @param {Object} curSched: The current schedule to add to\n * @param {Number} value: The value to add (x of x#y or xL)\n * @param {Number} hash: The hash value to add (y of x#y)\n */\nfunction addHash(schedules, curSched, value, hash) {\n  // if there are any existing day of week constraints that\n  // aren't equal to the one we're adding, create a new\n  // composite schedule\n  if ((curSched.d && !curSched.dc) ||\n    (curSched.dc && curSched.dc.indexOf(hash) < 0)) {\n    schedules.push(cloneSchedule(curSched));\n    curSched = schedules[schedules.length - 1];\n  }\n\n  add(curSched, 'd', value, value);\n  add(curSched, 'dc', hash, hash);\n}\n\n/**\n *\n * @param {Object} s: The existing set of schedules\n * @param {Object} curSched: The current schedule to add to\n * @param {Number} value\n */\nfunction addWeekday(s, curSched, value) {\n  var except1 = {}, except2 = {};\n  if (value === 1) {\n    // cron doesn't pass month boundaries, so if 1st is a\n    // weekend then we need to use 2nd or 3rd instead\n    add(curSched, 'D', 1, 3);\n    add(curSched, 'd', NAMES.MON, NAMES.FRI);\n    add(except1, 'D', 2, 2);\n    add(except1, 'd', NAMES.TUE, NAMES.FRI);\n    add(except2, 'D', 3, 3);\n    add(except2, 'd', NAMES.TUE, NAMES.FRI);\n  } else {\n    // normally you want the closest day, so if v is a\n    // Saturday, use the previous Friday.  If it's a\n    // sunday, use the following Monday.\n    add(curSched, 'D', value - 1, value + 1);\n    add(curSched, 'd', NAMES.MON, NAMES.FRI);\n    add(except1, 'D', value - 1, value - 1);\n    add(except1, 'd', NAMES.MON, NAMES.THU);\n    add(except2, 'D', value + 1, value + 1);\n    add(except2, 'd', NAMES.TUE, NAMES.FRI);\n  }\n  s.exceptions.push(except1);\n  s.exceptions.push(except2);\n}\n\n/**\n * Adds a range item (of the form x-y/z) to the schedule.\n *\n * @param {String} item: The cron expression item to add\n * @param {Object} curSched: The current schedule to add to\n * @param {String} name: The name to use for this constraint\n * @param {Number} min: The min value for the constraint\n * @param {Number} max: The max value for the constraint\n * @param {Number} offset: The offset to apply to the cron value\n */\nfunction addRange(item, curSched, name, min, max, offset) {\n  // parse range/x\n  var incSplit = item.split('/'),\n    inc = +incSplit[1],\n    range = incSplit[0];\n\n  // parse x-y or * or 0\n  if (range !== '*' && range !== '0') {\n    var rangeSplit = range.split('-');\n    min = getValue(rangeSplit[0], offset, max);\n\n    // fix for issue #13, range may be single digit\n    max = getValue(rangeSplit[1], offset, max) || max;\n  }\n\n  add(curSched, name, min, max, inc);\n}\n\n/**\n * Parses a particular item within a cron expression.\n *\n * @param {String} item: The cron expression item to parse\n * @param {Object} s: The existing set of schedules\n * @param {String} name: The name to use for this constraint\n * @param {Number} min: The min value for the constraint\n * @param {Number} max: The max value for the constraint\n * @param {Number} offset: The offset to apply to the cron value\n */\nfunction parse(item, s, name, min, max, offset) {\n  var value,\n    split,\n    schedules = s.schedules,\n    curSched = schedules[schedules.length - 1];\n\n  // L just means min - 1 (this also makes it work for any field)\n  if (item === 'L') {\n    item = (min - 1).toString(10);\n  }\n\n  // parse x\n  if ((value = getValue(item, offset, max)) !== null) {\n    add(curSched, name, value, value);\n  }\n  // parse xW\n  else if ((value = getValue(item.replace('W', ''), offset, max)) !== null) {\n    addWeekday(s, curSched, value);\n  }\n  // parse xL\n  else if ((value = getValue(item.replace('L', ''), offset, max)) !== null) {\n    addHash(schedules, curSched, value, min - 1);\n  }\n  // parse x#y\n  else if ((split = item.split('#')).length === 2) {\n    value = getValue(split[0], offset, max);\n    addHash(schedules, curSched, value, getValue(split[1]));\n  }\n  // parse x-y or x-y/z or */z or 0/z\n  else {\n    addRange(item, curSched, name, min, max, offset);\n  }\n}\n\n/**\n * Returns true if the item is either of the form x#y or xL.\n *\n * @param {String} item: The expression item to check\n */\nfunction isHash(item) {\n  return item.indexOf('#') > -1 || item.indexOf('L') > 0;\n}\n\n\nfunction itemSorter(a, b) {\n  return isHash(a) && !isHash(b) ? 1 : a - b;\n}\n\n/**\n * Parses each of the fields in a cron expression.  The expression must\n * include the seconds field, the year field is optional.\n *\n * @param {String} expr: The cron expression to parse\n */\nfunction parseExpr(expr) {\n  var schedule = {schedules: [{}], exceptions: []},\n    components = expr.replace(/(\\s)+/g, ' ').split(' '),\n    field, f, component, items;\n\n  for (field in FIELDS) {\n    f = FIELDS[field];\n    component = components[f[0]];\n    if (component && component !== '*' && component !== '?') {\n      // need to sort so that any #'s come last, otherwise\n      // schedule clones to handle # won't contain all of the\n      // other constraints\n      items = component.split(',').sort(itemSorter);\n      var i, length = items.length;\n      for (i = 0; i < length; i++) {\n        parse(items[i], schedule, field, f[1], f[2], f[3]);\n      }\n    }\n  }\n\n  return schedule;\n}\n\n/**\n * Make cron expression parsable.\n *\n * @param {String} expr: The cron expression to prepare\n */\nfunction prepareExpr(expr) {\n  var prepared = expr.toUpperCase();\n  return REPLACEMENTS[prepared] || prepared;\n}\n\nfunction parseCron(expr, hasSeconds) {\n  var e = prepareExpr(expr);\n  return parseExpr(hasSeconds ? e : '0 ' + e);\n}\n\nexport default parseCron;\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.cronToText = factory();\n})(this, function () {\n  'use strict';\n\n  // Constant array to convert valid names to values\n  var NAMES = {\n    JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8,\n    SEP: 9, OCT: 10, NOV: 11, DEC: 12,\n    SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7\n  };\n\n  // Parsable replacements for common expressions\n  var REPLACEMENTS = {\n    '* * * * * *': '0/1 * * * * *',\n    '@YEARLY': '0 0 1 1 *',\n    '@ANNUALLY': '0 0 1 1 *',\n    '@MONTHLY': '0 0 1 * *',\n    '@WEEKLY': '0 0 * * 0',\n    '@DAILY': '0 0 * * *',\n    '@HOURLY': '0 * * * *'\n  };\n\n  // Contains the index, min, and max for each of the constraints\n  var FIELDS = {\n    s: [0, 0, 59], // seconds\n    m: [1, 0, 59], // minutes\n    h: [2, 0, 23], // hours\n    D: [3, 1, 31], // day of month\n    M: [4, 1, 12], // month\n    Y: [6, 1970, 2099], // year\n    d: [5, 1, 7, 1] // day of week\n  };\n\n  /**\n   * Returns the value + offset if value is a number, otherwise it\n   * attempts to look up the value in the NAMES table and returns\n   * that result instead.\n   *\n   * @param {Number,String} value: The value that should be parsed\n   * @param {Number=} offset: Any offset that must be added to the value\n   * @param {Number=} max\n   * @returns {Number|null}\n   */\n  function getValue(value) {\n    var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n    var max = arguments.length <= 2 || arguments[2] === undefined ? 9999 : arguments[2];\n\n    return isNaN(value) ? NAMES[value] || null : Math.min(+value + offset, max);\n  }\n\n  /**\n   * Returns a deep clone of a schedule skipping any day of week\n   * constraints.\n   *\n   * @param {Object} sched: The schedule that will be cloned\n   * @returns {Object}\n   */\n  function cloneSchedule(sched) {\n    var clone = {},\n        field;\n\n    for (field in sched) {\n      if (field !== 'dc' && field !== 'd') {\n        clone[field] = sched[field].slice(0);\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n   * Adds values to the specified constraint in the current schedule.\n   *\n   * @param {Object} sched: The schedule to add the constraint to\n   * @param {String} name: Name of constraint to add\n   * @param {Number} min: Minimum value for this constraint\n   * @param {Number} max: Maximum value for this constraint\n   * @param {Number=} inc: The increment to use between min and max\n   */\n  function add(sched, name, min, max) {\n    var inc = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];\n\n    var i = min;\n\n    if (!sched[name]) {\n      sched[name] = [];\n    }\n\n    while (i <= max) {\n      if (sched[name].indexOf(i) < 0) {\n        sched[name].push(i);\n      }\n      i += inc || 1;\n    }\n\n    sched[name].sort(function (a, b) {\n      return a - b;\n    });\n  }\n\n  /**\n   * Adds a hash item (of the form x#y or xL) to the schedule.\n   *\n   * @param {Object} schedules: The current schedule array to add to\n   * @param {Object} curSched: The current schedule to add to\n   * @param {Number} value: The value to add (x of x#y or xL)\n   * @param {Number} hash: The hash value to add (y of x#y)\n   */\n  function addHash(schedules, curSched, value, hash) {\n    // if there are any existing day of week constraints that\n    // aren't equal to the one we're adding, create a new\n    // composite schedule\n    if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {\n      schedules.push(cloneSchedule(curSched));\n      curSched = schedules[schedules.length - 1];\n    }\n\n    add(curSched, 'd', value, value);\n    add(curSched, 'dc', hash, hash);\n  }\n\n  /**\n   *\n   * @param {Object} s: The existing set of schedules\n   * @param {Object} curSched: The current schedule to add to\n   * @param {Number} value\n   */\n  function addWeekday(s, curSched, value) {\n    var except1 = {},\n        except2 = {};\n    if (value === 1) {\n      // cron doesn't pass month boundaries, so if 1st is a\n      // weekend then we need to use 2nd or 3rd instead\n      add(curSched, 'D', 1, 3);\n      add(curSched, 'd', NAMES.MON, NAMES.FRI);\n      add(except1, 'D', 2, 2);\n      add(except1, 'd', NAMES.TUE, NAMES.FRI);\n      add(except2, 'D', 3, 3);\n      add(except2, 'd', NAMES.TUE, NAMES.FRI);\n    } else {\n      // normally you want the closest day, so if v is a\n      // Saturday, use the previous Friday.  If it's a\n      // sunday, use the following Monday.\n      add(curSched, 'D', value - 1, value + 1);\n      add(curSched, 'd', NAMES.MON, NAMES.FRI);\n      add(except1, 'D', value - 1, value - 1);\n      add(except1, 'd', NAMES.MON, NAMES.THU);\n      add(except2, 'D', value + 1, value + 1);\n      add(except2, 'd', NAMES.TUE, NAMES.FRI);\n    }\n    s.exceptions.push(except1);\n    s.exceptions.push(except2);\n  }\n\n  /**\n   * Adds a range item (of the form x-y/z) to the schedule.\n   *\n   * @param {String} item: The cron expression item to add\n   * @param {Object} curSched: The current schedule to add to\n   * @param {String} name: The name to use for this constraint\n   * @param {Number} min: The min value for the constraint\n   * @param {Number} max: The max value for the constraint\n   * @param {Number} offset: The offset to apply to the cron value\n   */\n  function addRange(item, curSched, name, min, max, offset) {\n    // parse range/x\n    var incSplit = item.split('/'),\n        inc = +incSplit[1],\n        range = incSplit[0];\n\n    // parse x-y or * or 0\n    if (range !== '*' && range !== '0') {\n      var rangeSplit = range.split('-');\n      min = getValue(rangeSplit[0], offset, max);\n\n      // fix for issue #13, range may be single digit\n      max = getValue(rangeSplit[1], offset, max) || max;\n    }\n\n    add(curSched, name, min, max, inc);\n  }\n\n  /**\n   * Parses a particular item within a cron expression.\n   *\n   * @param {String} item: The cron expression item to parse\n   * @param {Object} s: The existing set of schedules\n   * @param {String} name: The name to use for this constraint\n   * @param {Number} min: The min value for the constraint\n   * @param {Number} max: The max value for the constraint\n   * @param {Number} offset: The offset to apply to the cron value\n   */\n  function parse(item, s, name, min, max, offset) {\n    var value,\n        split,\n        schedules = s.schedules,\n        curSched = schedules[schedules.length - 1];\n\n    // L just means min - 1 (this also makes it work for any field)\n    if (item === 'L') {\n      item = (min - 1).toString(10);\n    }\n\n    // parse x\n    if ((value = getValue(item, offset, max)) !== null) {\n      add(curSched, name, value, value);\n    }\n    // parse xW\n    else if ((value = getValue(item.replace('W', ''), offset, max)) !== null) {\n        addWeekday(s, curSched, value);\n      }\n      // parse xL\n      else if ((value = getValue(item.replace('L', ''), offset, max)) !== null) {\n          addHash(schedules, curSched, value, min - 1);\n        }\n        // parse x#y\n        else if ((split = item.split('#')).length === 2) {\n            value = getValue(split[0], offset, max);\n            addHash(schedules, curSched, value, getValue(split[1]));\n          }\n          // parse x-y or x-y/z or */z or 0/z\n          else {\n              addRange(item, curSched, name, min, max, offset);\n            }\n  }\n\n  /**\n   * Returns true if the item is either of the form x#y or xL.\n   *\n   * @param {String} item: The expression item to check\n   */\n  function isHash(item) {\n    return item.indexOf('#') > -1 || item.indexOf('L') > 0;\n  }\n\n  function itemSorter(a, b) {\n    return isHash(a) && !isHash(b) ? 1 : a - b;\n  }\n\n  /**\n   * Parses each of the fields in a cron expression.  The expression must\n   * include the seconds field, the year field is optional.\n   *\n   * @param {String} expr: The cron expression to parse\n   */\n  function parseExpr(expr) {\n    var schedule = { schedules: [{}], exceptions: [] },\n        components = expr.replace(/(\\s)+/g, ' ').split(' '),\n        field,\n        f,\n        component,\n        items;\n\n    for (field in FIELDS) {\n      f = FIELDS[field];\n      component = components[f[0]];\n      if (component && component !== '*' && component !== '?') {\n        // need to sort so that any #'s come last, otherwise\n        // schedule clones to handle # won't contain all of the\n        // other constraints\n        items = component.split(',').sort(itemSorter);\n        var i,\n            length = items.length;\n        for (i = 0; i < length; i++) {\n          parse(items[i], schedule, field, f[1], f[2], f[3]);\n        }\n      }\n    }\n\n    return schedule;\n  }\n\n  /**\n   * Make cron expression parsable.\n   *\n   * @param {String} expr: The cron expression to prepare\n   */\n  function prepareExpr(expr) {\n    var prepared = expr.toUpperCase();\n    return REPLACEMENTS[prepared] || prepared;\n  }\n\n  function parseCron(expr, hasSeconds) {\n    var e = prepareExpr(expr);\n    return parseExpr(hasSeconds ? e : '0 ' + e);\n  }\n\n  var LOCALE = {\n    ORDINALS: {\n      th: 'th',\n      st: 'st',\n      nd: 'nd',\n      rd: 'rd'\n    },\n    MONTH: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    DOW: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n    'Every': 'Every', // start of expression\n    'and': 'and', // 1, 2, 3 and 15th\n    'every day': 'every day',\n    'minute past the': 'minute past the',\n    'hour': 'hour',\n    'minute': 'minute',\n    'minute of': 'minute of',\n    'minute every hour': 'minute every hour',\n    'on the': 'on the',\n    'of every month': 'of every month',\n    'and every': 'and every',\n    'on': 'on', // on sun, mon\n    'in': 'in' // in jan, apr\n  };\n\n  /**\n   * Given a cronspec, return the human-readable string.\n   * @param {string} cronspec\n   * @param sixth\n   * @param {Object=} locale\n   */\n  function cronToText(cronspec, sixth) {\n    var locale = arguments.length <= 2 || arguments[2] === undefined ? LOCALE : arguments[2];\n\n    var schedule = parseCron(cronspec, sixth);\n\n    function absFloor(number) {\n      if (number < 0) {\n        return Math.ceil(number);\n      } else {\n        return Math.floor(number);\n      }\n    }\n\n    function toInt(argumentForCoercion) {\n      var coercedNumber = +argumentForCoercion,\n          value = 0;\n\n      if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n        value = absFloor(coercedNumber);\n      }\n\n      return value;\n    }\n\n    function ordinal(number) {\n      var b = number % 10,\n          output = toInt(number % 100 / 10) === 1 ? locale.ORDINALS.th : b === 1 ? locale.ORDINALS.st : b === 2 ? locale.ORDINALS.nd : b === 3 ? locale.ORDINALS.rd : locale.ORDINALS.th;\n      return number + output;\n    }\n\n    /**\n     * For an array of numbers, e.g. a list of hours in a schedule,\n     * return a string listing out all of the values (complete with\n     * \"and\" plus ordinal text on the last item).\n     * @param {Number[]} numbers\n     * @returns {string}\n     */\n    function numberList(numbers) {\n      if (numbers.length < 2) {\n        return ordinal(numbers);\n      }\n\n      var lastVal = numbers.pop();\n      return numbers.join(', ') + (' ' + locale['and'] + ' ') + ordinal(lastVal);\n    }\n\n    /**\n     * Parse a number into day of week, or a month name;\n     * used in dateList below.\n     * @param {Number|String} value\n     * @param {String} type\n     * @returns {String}\n     */\n    function numberToDateName(value, type) {\n      if (type == 'dow') {\n        return locale.DOW[value - 1];\n      } else if (type == 'mon') {\n        return locale.MONTH[value - 1];\n      }\n    }\n\n    /**\n     * From an array of numbers corresponding to dates (given in type: either\n     * days of the week, or months), return a string listing all the values.\n     * @param {Number[]} numbers\n     * @param {String} type\n     * @returns {String}\n     */\n    function dateList(numbers, type) {\n      if (numbers.length < 2) {\n        return numberToDateName('' + numbers[0], type);\n      }\n\n      var lastVal = '' + numbers.pop();\n      var outputText = '';\n\n      for (var i = 0, value; value = numbers[i]; i++) {\n        if (outputText.length > 0) {\n          outputText += ', ';\n        }\n        outputText += numberToDateName(value, type);\n      }\n      return outputText + (' ' + locale['and'] + ' ') + numberToDateName(lastVal, type);\n    }\n\n    /**\n     * Pad to equivalent of sprintf('%02d').\n     * @param {Number} x\n     * @returns {string}\n     */\n    function zeroPad(x) {\n      return x < 10 ? '0' + x : x;\n    }\n\n    //----------------\n\n    /**\n     * Given a schedule, generate a friendly sentence description.\n     * @param {Object} schedule\n     * @returns {string}\n     */\n    function scheduleToSentence(schedule) {\n      var outputText = locale.Every + ' ';\n\n      if (schedule['h'] && schedule['m'] && schedule['h'].length <= 2 && schedule['m'].length <= 2) {\n        // If there are only one or two specified values for\n        // hour or minute, print them in HH:MM format\n\n        var hm = [];\n        for (var i = 0; i < schedule['h'].length; i++) {\n          for (var j = 0; j < schedule['m'].length; j++) {\n            hm.push(zeroPad(schedule['h'][i]) + ':' + zeroPad(schedule['m'][j]));\n          }\n        }\n        if (hm.length < 2) {\n          outputText = hm[0];\n        } else {\n          var lastVal = hm.pop();\n          outputText = hm.join(', ') + (' ' + locale.and + ' ') + lastVal;\n        }\n        if (!schedule['d'] && !schedule['D']) {\n          outputText += ' ' + locale['every day'];\n        }\n      } else {\n        // Otherwise, list out every specified hour/minute value.\n\n        if (schedule['h']) {\n          // runs only at specific hours\n          if (schedule['m']) {\n            // and only at specific minutes\n            outputText += numberList(schedule['m']) + (' ' + locale['minute past the'] + ' ') + numberList(schedule['h']) + (' ' + locale['hour']);\n          } else {\n            // specific hours, but every minute\n            outputText += locale['minute of'] + ' ' + numberList(schedule['h']) + (' ' + locale['hour']);\n          }\n        } else if (schedule['m']) {\n          // every hour, but specific minutes\n          outputText += numberList(schedule['m']) + (' ' + locale['minute every hour']);\n        } else {\n          // cronspec has \"*\" for both hour and minute\n          outputText += locale['minute'];\n        }\n      }\n\n      if (schedule['D']) {\n        // runs only on specific day(s) of month\n        outputText += (locale['on the'] ? ' ' + locale['on the'] + ' ' : ' ') + numberList(schedule['D']);\n        if (!schedule['M']) {\n          outputText += ' ' + locale['of every month'];\n        }\n      }\n\n      if (schedule['d']) {\n        // runs only on specific day(s) of week\n        if (schedule['D']) {\n          // if both day fields are specified, cron uses both; superuser.com/a/348372\n          outputText += ' ' + locale['and every'] + ' ';\n        } else {\n          outputText += ' ' + locale['on'] + ' ';\n        }\n        outputText += dateList(schedule['d'], 'dow');\n      }\n\n      if (schedule['M']) {\n        // runs only in specific months; put this output last\n        outputText += ' ' + locale['in'] + ' ' + dateList(schedule['M'], 'mon');\n      }\n\n      return outputText;\n    }\n\n    return scheduleToSentence(schedule.schedules[0]);\n  }\n\n  var cron_to_text = cronToText;\n\n  return cron_to_text;\n});\n//# sourceMappingURL=cron-to-text.js.map\n","import parseCron from './parseCron';\n\nconst LOCALE = {\n  ORDINALS: {\n    th: 'th',\n    st: 'st',\n    nd: 'nd',\n    rd: 'rd'\n  },\n  MONTH: [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec'\n  ],\n  DOW: [\n    'Sun',\n    'Mon',\n    'Tue',\n    'Wed',\n    'Thu',\n    'Fri',\n    'Sat'\n  ],\n  'Every': 'Every', // start of expression\n  'and': 'and', // 1, 2, 3 and 15th\n  'every day': 'every day',\n  'minute past the': 'minute past the',\n  'hour': 'hour',\n  'minute': 'minute',\n  'minute of': 'minute of',\n  'minute every hour': 'minute every hour',\n  'on the': 'on the',\n  'of every month': 'of every month',\n  'and every': 'and every',\n  'on': 'on', // on sun, mon\n  'in': 'in' // in jan, apr\n};\n\n/**\n * Given a cronspec, return the human-readable string.\n * @param {string} cronspec\n * @param sixth\n * @param {Object=} locale\n */\nfunction cronToText(cronspec, sixth, locale = LOCALE) {\n  var schedule = parseCron(cronspec, sixth);\n\n  function absFloor(number) {\n    if (number < 0) {\n      return Math.ceil(number);\n    } else {\n      return Math.floor(number);\n    }\n  }\n\n  function toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n      value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n      value = absFloor(coercedNumber);\n    }\n\n    return value;\n  }\n\n  function ordinal(number) {\n    var b = number % 10,\n      output = (toInt(number % 100 / 10) === 1) ? locale.ORDINALS.th :\n        (b === 1) ? locale.ORDINALS.st :\n          (b === 2) ? locale.ORDINALS.nd :\n            (b === 3) ? locale.ORDINALS.rd : locale.ORDINALS.th;\n    return number + output;\n  }\n\n  /**\n   * For an array of numbers, e.g. a list of hours in a schedule,\n   * return a string listing out all of the values (complete with\n   * \"and\" plus ordinal text on the last item).\n   * @param {Number[]} numbers\n   * @returns {string}\n   */\n  function numberList(numbers) {\n    if (numbers.length < 2) {\n      return ordinal(numbers);\n    }\n\n    var lastVal = numbers.pop();\n    return numbers.join(', ') + ` ${locale['and']} ` + ordinal(lastVal);\n  }\n\n  /**\n   * Parse a number into day of week, or a month name;\n   * used in dateList below.\n   * @param {Number|String} value\n   * @param {String} type\n   * @returns {String}\n   */\n  function numberToDateName(value, type) {\n    if (type == 'dow') {\n      return locale.DOW[value - 1];\n    } else if (type == 'mon') {\n      return locale.MONTH[value - 1];\n    }\n  }\n\n  /**\n   * From an array of numbers corresponding to dates (given in type: either\n   * days of the week, or months), return a string listing all the values.\n   * @param {Number[]} numbers\n   * @param {String} type\n   * @returns {String}\n   */\n  function dateList(numbers, type) {\n    if (numbers.length < 2) {\n      return numberToDateName('' + numbers[0], type);\n    }\n\n    var lastVal = '' + numbers.pop();\n    var outputText = '';\n\n    for (var i = 0, value; value = numbers[i]; i++) {\n      if (outputText.length > 0) {\n        outputText += ', ';\n      }\n      outputText += numberToDateName(value, type);\n    }\n    return outputText + ` ${locale['and']} ` + numberToDateName(lastVal, type);\n  }\n\n  /**\n   * Pad to equivalent of sprintf('%02d').\n   * @param {Number} x\n   * @returns {string}\n   */\n  function zeroPad(x) {\n    return (x < 10) ? '0' + x : x;\n  }\n\n  //----------------\n\n  /**\n   * Given a schedule, generate a friendly sentence description.\n   * @param {Object} schedule\n   * @returns {string}\n   */\n  function scheduleToSentence(schedule) {\n    var outputText = locale.Every + ' ';\n\n    if (schedule['h'] && schedule['m'] && schedule['h'].length <= 2 && schedule['m'].length <= 2) {\n      // If there are only one or two specified values for\n      // hour or minute, print them in HH:MM format\n\n      var hm = [];\n      for (var i = 0; i < schedule['h'].length; i++) {\n        for (var j = 0; j < schedule['m'].length; j++) {\n          hm.push(zeroPad(schedule['h'][i]) + ':' + zeroPad(schedule['m'][j]));\n        }\n      }\n      if (hm.length < 2) {\n        outputText = hm[0];\n      } else {\n        var lastVal = hm.pop();\n        outputText = hm.join(', ') + ` ${locale.and} ` + lastVal;\n      }\n      if (!schedule['d'] && !schedule['D']) {\n        outputText += ` ${locale['every day']}`;\n      }\n    } else {\n      // Otherwise, list out every specified hour/minute value.\n\n      if (schedule['h']) { // runs only at specific hours\n        if (schedule['m']) { // and only at specific minutes\n          outputText += numberList(schedule['m']) + ` ${locale['minute past the']} ` + numberList(schedule['h']) + ` ${locale['hour']}`;\n        } else { // specific hours, but every minute\n          outputText += `${locale['minute of']} ` + numberList(schedule['h']) + ` ${locale['hour']}`;\n        }\n      } else if (schedule['m']) { // every hour, but specific minutes\n        outputText += numberList(schedule['m']) + ` ${locale['minute every hour']}`;\n      } else { // cronspec has \"*\" for both hour and minute\n        outputText += locale['minute'];\n      }\n    }\n\n    if (schedule['D']) { // runs only on specific day(s) of month\n      outputText += (locale['on the'] ? ` ${locale['on the']} ` : ' ') + numberList(schedule['D']);\n      if (!schedule['M']) {\n        outputText += ` ${locale['of every month']}`;\n      }\n    }\n\n    if (schedule['d']) { // runs only on specific day(s) of week\n      if (schedule['D']) {\n        // if both day fields are specified, cron uses both; superuser.com/a/348372\n        outputText += ` ${locale['and every']} `;\n      } else {\n        outputText += ` ${locale['on']} `;\n      }\n      outputText += dateList(schedule['d'], 'dow');\n    }\n\n    if (schedule['M']) {\n      // runs only in specific months; put this output last\n      outputText += ` ${locale['in']} ` + dateList(schedule['M'], 'mon');\n    }\n\n    return outputText;\n  }\n\n  return scheduleToSentence(schedule.schedules[0]);\n}\n\nexport default cronToText;\n"],"sourceRoot":"/source/"}