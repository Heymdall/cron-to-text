{"version":3,"sources":["cron-to-text.js","src/parseCron.js","src/cron-to-text.js"],"names":[],"mappings":"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","file":"cron-to-text.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.cronToText = factory()\n}(this, function () { 'use strict';\n\n  // Constant array to convert valid names to values\n  const NAMES = {\n    JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8,\n    SEP: 9, OCT: 10, NOV: 11, DEC: 12,\n    SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7\n  };\n\n  // Parsable replacements for common expressions\n  const REPLACEMENTS = {\n    '* * * * * *': '0/1 * * * * *',\n    '@YEARLY': '0 0 1 1 *',\n    '@ANNUALLY': '0 0 1 1 *',\n    '@MONTHLY': '0 0 1 * *',\n    '@WEEKLY': '0 0 * * 0',\n    '@DAILY': '0 0 * * *',\n    '@HOURLY': '0 * * * *'\n  };\n\n  // Contains the index, min, and max for each of the constraints\n  const FIELDS = {\n    s: [0, 0, 59],      // seconds\n    m: [1, 0, 59],      // minutes\n    h: [2, 0, 23],      // hours\n    D: [3, 1, 31],      // day of month\n    M: [4, 1, 12],      // month\n    Y: [6, 1970, 2099], // year\n    d: [5, 1, 7, 1]     // day of week\n  };\n\n  /**\n   * Returns the value + offset if value is a number, otherwise it\n   * attempts to look up the value in the NAMES table and returns\n   * that result instead.\n   *\n   * @param {Number,String} value: The value that should be parsed\n   * @param {Number=} offset: Any offset that must be added to the value\n   * @param {Number=} max\n   * @returns {Number|null}\n   */\n  function getValue(value, offset = 0, max = 9999) {\n    return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset), max);\n  }\n\n  /**\n   * Returns a deep clone of a schedule skipping any day of week\n   * constraints.\n   *\n   * @param {Object} sched: The schedule that will be cloned\n   * @returns {Object}\n   */\n  function cloneSchedule(sched) {\n    var clone = {}, field;\n\n    for (field in sched) {\n      if (field !== 'dc' && field !== 'd') {\n        clone[field] = sched[field].slice(0);\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n   * Adds values to the specified constraint in the current schedule.\n   *\n   * @param {Object} sched: The schedule to add the constraint to\n   * @param {String} name: Name of constraint to add\n   * @param {Number} min: Minimum value for this constraint\n   * @param {Number} max: Maximum value for this constraint\n   * @param {Number=} inc: The increment to use between min and max\n   */\n  function add(sched, name, min, max, inc = 0) {\n    var i = min;\n\n    if (!sched[name]) {\n      sched[name] = [];\n    }\n\n    while (i <= max) {\n      if (sched[name].indexOf(i) < 0) {\n        sched[name].push(i);\n      }\n      i += inc || 1;\n    }\n\n    sched[name].sort(function (a, b) {\n      return a - b;\n    });\n  }\n\n  /**\n   * Adds a hash item (of the form x#y or xL) to the schedule.\n   *\n   * @param {Object} schedules: The current schedule array to add to\n   * @param {Object} curSched: The current schedule to add to\n   * @param {Number} value: The value to add (x of x#y or xL)\n   * @param {Number} hash: The hash value to add (y of x#y)\n   */\n  function addHash(schedules, curSched, value, hash) {\n    // if there are any existing day of week constraints that\n    // aren't equal to the one we're adding, create a new\n    // composite schedule\n    if ((curSched.d && !curSched.dc) ||\n      (curSched.dc && curSched.dc.indexOf(hash) < 0)) {\n      schedules.push(cloneSchedule(curSched));\n      curSched = schedules[schedules.length - 1];\n    }\n\n    add(curSched, 'd', value, value);\n    add(curSched, 'dc', hash, hash);\n  }\n\n  /**\n   *\n   * @param {Object} s: The existing set of schedules\n   * @param {Object} curSched: The current schedule to add to\n   * @param {Number} value\n   */\n  function addWeekday(s, curSched, value) {\n    var except1 = {}, except2 = {};\n    if (value === 1) {\n      // cron doesn't pass month boundaries, so if 1st is a\n      // weekend then we need to use 2nd or 3rd instead\n      add(curSched, 'D', 1, 3);\n      add(curSched, 'd', NAMES.MON, NAMES.FRI);\n      add(except1, 'D', 2, 2);\n      add(except1, 'd', NAMES.TUE, NAMES.FRI);\n      add(except2, 'D', 3, 3);\n      add(except2, 'd', NAMES.TUE, NAMES.FRI);\n    } else {\n      // normally you want the closest day, so if v is a\n      // Saturday, use the previous Friday.  If it's a\n      // sunday, use the following Monday.\n      add(curSched, 'D', value - 1, value + 1);\n      add(curSched, 'd', NAMES.MON, NAMES.FRI);\n      add(except1, 'D', value - 1, value - 1);\n      add(except1, 'd', NAMES.MON, NAMES.THU);\n      add(except2, 'D', value + 1, value + 1);\n      add(except2, 'd', NAMES.TUE, NAMES.FRI);\n    }\n    s.exceptions.push(except1);\n    s.exceptions.push(except2);\n  }\n\n  /**\n   * Adds a range item (of the form x-y/z) to the schedule.\n   *\n   * @param {String} item: The cron expression item to add\n   * @param {Object} curSched: The current schedule to add to\n   * @param {String} name: The name to use for this constraint\n   * @param {Number} min: The min value for the constraint\n   * @param {Number} max: The max value for the constraint\n   * @param {Number} offset: The offset to apply to the cron value\n   */\n  function addRange(item, curSched, name, min, max, offset) {\n    // parse range/x\n    var incSplit = item.split('/'),\n      inc = +incSplit[1],\n      range = incSplit[0];\n\n    // parse x-y or * or 0\n    if (range !== '*' && range !== '0') {\n      var rangeSplit = range.split('-');\n      min = getValue(rangeSplit[0], offset, max);\n\n      // fix for issue #13, range may be single digit\n      max = getValue(rangeSplit[1], offset, max) || max;\n    }\n\n    add(curSched, name, min, max, inc);\n  }\n\n  /**\n   * Parses a particular item within a cron expression.\n   *\n   * @param {String} item: The cron expression item to parse\n   * @param {Object} s: The existing set of schedules\n   * @param {String} name: The name to use for this constraint\n   * @param {Number} min: The min value for the constraint\n   * @param {Number} max: The max value for the constraint\n   * @param {Number} offset: The offset to apply to the cron value\n   */\n  function parse(item, s, name, min, max, offset) {\n    var value,\n      split,\n      schedules = s.schedules,\n      curSched = schedules[schedules.length - 1];\n\n    // L just means min - 1 (this also makes it work for any field)\n    if (item === 'L') {\n      item = (min - 1).toString(10);\n    }\n\n    // parse x\n    if ((value = getValue(item, offset, max)) !== null) {\n      add(curSched, name, value, value);\n    }\n    // parse xW\n    else if ((value = getValue(item.replace('W', ''), offset, max)) !== null) {\n      addWeekday(s, curSched, value);\n    }\n    // parse xL\n    else if ((value = getValue(item.replace('L', ''), offset, max)) !== null) {\n      addHash(schedules, curSched, value, min - 1);\n    }\n    // parse x#y\n    else if ((split = item.split('#')).length === 2) {\n      value = getValue(split[0], offset, max);\n      addHash(schedules, curSched, value, getValue(split[1]));\n    }\n    // parse x-y or x-y/z or */z or 0/z\n    else {\n      addRange(item, curSched, name, min, max, offset);\n    }\n  }\n\n  /**\n   * Returns true if the item is either of the form x#y or xL.\n   *\n   * @param {String} item: The expression item to check\n   */\n  function isHash(item) {\n    return item.indexOf('#') > -1 || item.indexOf('L') > 0;\n  }\n\n\n  function itemSorter(a, b) {\n    return isHash(a) && !isHash(b) ? 1 : a - b;\n  }\n\n  /**\n   * Parses each of the fields in a cron expression.  The expression must\n   * include the seconds field, the year field is optional.\n   *\n   * @param {String} expr: The cron expression to parse\n   */\n  function parseExpr(expr) {\n    var schedule = {schedules: [{}], exceptions: []},\n      components = expr.replace(/(\\s)+/g, ' ').split(' '),\n      field, f, component, items;\n\n    for (field in FIELDS) {\n      f = FIELDS[field];\n      component = components[f[0]];\n      if (component && component !== '*' && component !== '?') {\n        // need to sort so that any #'s come last, otherwise\n        // schedule clones to handle # won't contain all of the\n        // other constraints\n        items = component.split(',').sort(itemSorter);\n        var i, length = items.length;\n        for (i = 0; i < length; i++) {\n          parse(items[i], schedule, field, f[1], f[2], f[3]);\n        }\n      }\n    }\n\n    return schedule;\n  }\n\n  /**\n   * Make cron expression parsable.\n   *\n   * @param {String} expr: The cron expression to prepare\n   */\n  function prepareExpr(expr) {\n    var prepared = expr.toUpperCase();\n    return REPLACEMENTS[prepared] || prepared;\n  }\n\n  function parseCron(expr, hasSeconds) {\n    var e = prepareExpr(expr);\n    return parseExpr(hasSeconds ? e : '0 ' + e);\n  }\n\n  const LOCALE = {\n    ORDINALS: {\n      th: 'th',\n      st: 'st',\n      nd: 'nd',\n      rd: 'rd'\n    },\n    MONTH: [\n      'Jan',\n      'Feb',\n      'Mar',\n      'Apr',\n      'May',\n      'Jun',\n      'Jul',\n      'Aug',\n      'Sep',\n      'Oct',\n      'Nov',\n      'Dec'\n    ],\n    DOW: [\n      'Sun',\n      'Mon',\n      'Tue',\n      'Wed',\n      'Thu',\n      'Fri',\n      'Sat'\n    ],\n    'Every': 'Every', // start of expression\n    'and': 'and', // 1, 2, 3 and 15th\n    'every day': 'every day',\n    'minute past the': 'minute past the',\n    'hour': 'hour',\n    'minute': 'minute',\n    'minute of': 'minute of',\n    'minute every hour': 'minute every hour',\n    'on the': 'on the',\n    'of every month': 'of every month',\n    'and every': 'and every',\n    'on': 'on', // on sun, mon\n    'in': 'in' // in jan, apr\n  };\n\n  /**\n   * Given a cronspec, return the human-readable string.\n   * @param {string} cronspec\n   * @param sixth\n   * @param {Object=} locale\n   */\n  function cronToText(cronspec, sixth, locale = LOCALE) {\n    var schedule = parseCron(cronspec, sixth);\n\n    function absFloor(number) {\n      if (number < 0) {\n        return Math.ceil(number);\n      } else {\n        return Math.floor(number);\n      }\n    }\n\n    function toInt(argumentForCoercion) {\n      var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n      if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n        value = absFloor(coercedNumber);\n      }\n\n      return value;\n    }\n\n    function ordinal(number) {\n      var b = number % 10,\n        output = (toInt(number % 100 / 10) === 1) ? locale.ORDINALS.th :\n          (b === 1) ? locale.ORDINALS.st :\n            (b === 2) ? locale.ORDINALS.nd :\n              (b === 3) ? locale.ORDINALS.rd : locale.ORDINALS.th;\n      return number + output;\n    }\n\n    /**\n     * For an array of numbers, e.g. a list of hours in a schedule,\n     * return a string listing out all of the values (complete with\n     * \"and\" plus ordinal text on the last item).\n     * @param {Number[]} numbers\n     * @returns {string}\n     */\n    function numberList(numbers) {\n      if (numbers.length < 2) {\n        return ordinal(numbers);\n      }\n\n      var lastVal = numbers.pop();\n      return numbers.join(', ') + ` ${locale['and']} ` + ordinal(lastVal);\n    }\n\n    /**\n     * Parse a number into day of week, or a month name;\n     * used in dateList below.\n     * @param {Number|String} value\n     * @param {String} type\n     * @returns {String}\n     */\n    function numberToDateName(value, type) {\n      if (type == 'dow') {\n        return locale.DOW[value - 1];\n      } else if (type == 'mon') {\n        return locale.MONTH[value - 1];\n      }\n    }\n\n    /**\n     * From an array of numbers corresponding to dates (given in type: either\n     * days of the week, or months), return a string listing all the values.\n     * @param {Number[]} numbers\n     * @param {String} type\n     * @returns {String}\n     */\n    function dateList(numbers, type) {\n      if (numbers.length < 2) {\n        return numberToDateName('' + numbers[0], type);\n      }\n\n      var lastVal = '' + numbers.pop();\n      var outputText = '';\n\n      for (var i = 0, value; value = numbers[i]; i++) {\n        if (outputText.length > 0) {\n          outputText += ', ';\n        }\n        outputText += numberToDateName(value, type);\n      }\n      return outputText + ` ${locale['and']} ` + numberToDateName(lastVal, type);\n    }\n\n    /**\n     * Pad to equivalent of sprintf('%02d').\n     * @param {Number} x\n     * @returns {string}\n     */\n    function zeroPad(x) {\n      return (x < 10) ? '0' + x : x;\n    }\n\n    //----------------\n\n    /**\n     * Given a schedule, generate a friendly sentence description.\n     * @param {Object} schedule\n     * @returns {string}\n     */\n    function scheduleToSentence(schedule) {\n      var outputText = locale.Every + ' ';\n\n      if (schedule['h'] && schedule['m'] && schedule['h'].length <= 2 && schedule['m'].length <= 2) {\n        // If there are only one or two specified values for\n        // hour or minute, print them in HH:MM format\n\n        var hm = [];\n        for (var i = 0; i < schedule['h'].length; i++) {\n          for (var j = 0; j < schedule['m'].length; j++) {\n            hm.push(zeroPad(schedule['h'][i]) + ':' + zeroPad(schedule['m'][j]));\n          }\n        }\n        if (hm.length < 2) {\n          outputText = hm[0];\n        } else {\n          var lastVal = hm.pop();\n          outputText = hm.join(', ') + ` ${locale.and} ` + lastVal;\n        }\n        if (!schedule['d'] && !schedule['D']) {\n          outputText += ` ${locale['every day']}`;\n        }\n      } else {\n        // Otherwise, list out every specified hour/minute value.\n\n        if (schedule['h']) { // runs only at specific hours\n          if (schedule['m']) { // and only at specific minutes\n            outputText += numberList(schedule['m']) + ` ${locale['minute past the']} ` + numberList(schedule['h']) + ` ${locale['hour']}`;\n          } else { // specific hours, but every minute\n            outputText += `${locale['minute of']} ` + numberList(schedule['h']) + ` ${locale['hour']}`;\n          }\n        } else if (schedule['m']) { // every hour, but specific minutes\n          outputText += numberList(schedule['m']) + ` ${locale['minute every hour']}`;\n        } else { // cronspec has \"*\" for both hour and minute\n          outputText += locale['minute'];\n        }\n      }\n\n      if (schedule['D']) { // runs only on specific day(s) of month\n        outputText += (locale['on the'] ? ` ${locale['on the']} ` : ' ') + numberList(schedule['D']);\n        if (!schedule['M']) {\n          outputText += ` ${locale['of every month']}`;\n        }\n      }\n\n      if (schedule['d']) { // runs only on specific day(s) of week\n        if (schedule['D']) {\n          // if both day fields are specified, cron uses both; superuser.com/a/348372\n          outputText += ` ${locale['and every']} `;\n        } else {\n          outputText += ` ${locale['on']} `;\n        }\n        outputText += dateList(schedule['d'], 'dow');\n      }\n\n      if (schedule['M']) {\n        // runs only in specific months; put this output last\n        outputText += ` ${locale['in']} ` + dateList(schedule['M'], 'mon');\n      }\n\n      return outputText;\n    }\n\n    return scheduleToSentence(schedule.schedules[0]);\n  }\n\n  var cron_to_text = cronToText;\n\n  return cron_to_text;\n\n}));\n","// Constant array to convert valid names to values\nconst NAMES = {\n  JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8,\n  SEP: 9, OCT: 10, NOV: 11, DEC: 12,\n  SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7\n};\n\n// Parsable replacements for common expressions\nconst REPLACEMENTS = {\n  '* * * * * *': '0/1 * * * * *',\n  '@YEARLY': '0 0 1 1 *',\n  '@ANNUALLY': '0 0 1 1 *',\n  '@MONTHLY': '0 0 1 * *',\n  '@WEEKLY': '0 0 * * 0',\n  '@DAILY': '0 0 * * *',\n  '@HOURLY': '0 * * * *'\n};\n\n// Contains the index, min, and max for each of the constraints\nconst FIELDS = {\n  s: [0, 0, 59],      // seconds\n  m: [1, 0, 59],      // minutes\n  h: [2, 0, 23],      // hours\n  D: [3, 1, 31],      // day of month\n  M: [4, 1, 12],      // month\n  Y: [6, 1970, 2099], // year\n  d: [5, 1, 7, 1]     // day of week\n};\n\n/**\n * Returns the value + offset if value is a number, otherwise it\n * attempts to look up the value in the NAMES table and returns\n * that result instead.\n *\n * @param {Number,String} value: The value that should be parsed\n * @param {Number=} offset: Any offset that must be added to the value\n * @param {Number=} max\n * @returns {Number|null}\n */\nfunction getValue(value, offset = 0, max = 9999) {\n  return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset), max);\n}\n\n/**\n * Returns a deep clone of a schedule skipping any day of week\n * constraints.\n *\n * @param {Object} sched: The schedule that will be cloned\n * @returns {Object}\n */\nfunction cloneSchedule(sched) {\n  var clone = {}, field;\n\n  for (field in sched) {\n    if (field !== 'dc' && field !== 'd') {\n      clone[field] = sched[field].slice(0);\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Adds values to the specified constraint in the current schedule.\n *\n * @param {Object} sched: The schedule to add the constraint to\n * @param {String} name: Name of constraint to add\n * @param {Number} min: Minimum value for this constraint\n * @param {Number} max: Maximum value for this constraint\n * @param {Number=} inc: The increment to use between min and max\n */\nfunction add(sched, name, min, max, inc = 0) {\n  var i = min;\n\n  if (!sched[name]) {\n    sched[name] = [];\n  }\n\n  while (i <= max) {\n    if (sched[name].indexOf(i) < 0) {\n      sched[name].push(i);\n    }\n    i += inc || 1;\n  }\n\n  sched[name].sort(function (a, b) {\n    return a - b;\n  });\n}\n\n/**\n * Adds a hash item (of the form x#y or xL) to the schedule.\n *\n * @param {Object} schedules: The current schedule array to add to\n * @param {Object} curSched: The current schedule to add to\n * @param {Number} value: The value to add (x of x#y or xL)\n * @param {Number} hash: The hash value to add (y of x#y)\n */\nfunction addHash(schedules, curSched, value, hash) {\n  // if there are any existing day of week constraints that\n  // aren't equal to the one we're adding, create a new\n  // composite schedule\n  if ((curSched.d && !curSched.dc) ||\n    (curSched.dc && curSched.dc.indexOf(hash) < 0)) {\n    schedules.push(cloneSchedule(curSched));\n    curSched = schedules[schedules.length - 1];\n  }\n\n  add(curSched, 'd', value, value);\n  add(curSched, 'dc', hash, hash);\n}\n\n/**\n *\n * @param {Object} s: The existing set of schedules\n * @param {Object} curSched: The current schedule to add to\n * @param {Number} value\n */\nfunction addWeekday(s, curSched, value) {\n  var except1 = {}, except2 = {};\n  if (value === 1) {\n    // cron doesn't pass month boundaries, so if 1st is a\n    // weekend then we need to use 2nd or 3rd instead\n    add(curSched, 'D', 1, 3);\n    add(curSched, 'd', NAMES.MON, NAMES.FRI);\n    add(except1, 'D', 2, 2);\n    add(except1, 'd', NAMES.TUE, NAMES.FRI);\n    add(except2, 'D', 3, 3);\n    add(except2, 'd', NAMES.TUE, NAMES.FRI);\n  } else {\n    // normally you want the closest day, so if v is a\n    // Saturday, use the previous Friday.  If it's a\n    // sunday, use the following Monday.\n    add(curSched, 'D', value - 1, value + 1);\n    add(curSched, 'd', NAMES.MON, NAMES.FRI);\n    add(except1, 'D', value - 1, value - 1);\n    add(except1, 'd', NAMES.MON, NAMES.THU);\n    add(except2, 'D', value + 1, value + 1);\n    add(except2, 'd', NAMES.TUE, NAMES.FRI);\n  }\n  s.exceptions.push(except1);\n  s.exceptions.push(except2);\n}\n\n/**\n * Adds a range item (of the form x-y/z) to the schedule.\n *\n * @param {String} item: The cron expression item to add\n * @param {Object} curSched: The current schedule to add to\n * @param {String} name: The name to use for this constraint\n * @param {Number} min: The min value for the constraint\n * @param {Number} max: The max value for the constraint\n * @param {Number} offset: The offset to apply to the cron value\n */\nfunction addRange(item, curSched, name, min, max, offset) {\n  // parse range/x\n  var incSplit = item.split('/'),\n    inc = +incSplit[1],\n    range = incSplit[0];\n\n  // parse x-y or * or 0\n  if (range !== '*' && range !== '0') {\n    var rangeSplit = range.split('-');\n    min = getValue(rangeSplit[0], offset, max);\n\n    // fix for issue #13, range may be single digit\n    max = getValue(rangeSplit[1], offset, max) || max;\n  }\n\n  add(curSched, name, min, max, inc);\n}\n\n/**\n * Parses a particular item within a cron expression.\n *\n * @param {String} item: The cron expression item to parse\n * @param {Object} s: The existing set of schedules\n * @param {String} name: The name to use for this constraint\n * @param {Number} min: The min value for the constraint\n * @param {Number} max: The max value for the constraint\n * @param {Number} offset: The offset to apply to the cron value\n */\nfunction parse(item, s, name, min, max, offset) {\n  var value,\n    split,\n    schedules = s.schedules,\n    curSched = schedules[schedules.length - 1];\n\n  // L just means min - 1 (this also makes it work for any field)\n  if (item === 'L') {\n    item = (min - 1).toString(10);\n  }\n\n  // parse x\n  if ((value = getValue(item, offset, max)) !== null) {\n    add(curSched, name, value, value);\n  }\n  // parse xW\n  else if ((value = getValue(item.replace('W', ''), offset, max)) !== null) {\n    addWeekday(s, curSched, value);\n  }\n  // parse xL\n  else if ((value = getValue(item.replace('L', ''), offset, max)) !== null) {\n    addHash(schedules, curSched, value, min - 1);\n  }\n  // parse x#y\n  else if ((split = item.split('#')).length === 2) {\n    value = getValue(split[0], offset, max);\n    addHash(schedules, curSched, value, getValue(split[1]));\n  }\n  // parse x-y or x-y/z or */z or 0/z\n  else {\n    addRange(item, curSched, name, min, max, offset);\n  }\n}\n\n/**\n * Returns true if the item is either of the form x#y or xL.\n *\n * @param {String} item: The expression item to check\n */\nfunction isHash(item) {\n  return item.indexOf('#') > -1 || item.indexOf('L') > 0;\n}\n\n\nfunction itemSorter(a, b) {\n  return isHash(a) && !isHash(b) ? 1 : a - b;\n}\n\n/**\n * Parses each of the fields in a cron expression.  The expression must\n * include the seconds field, the year field is optional.\n *\n * @param {String} expr: The cron expression to parse\n */\nfunction parseExpr(expr) {\n  var schedule = {schedules: [{}], exceptions: []},\n    components = expr.replace(/(\\s)+/g, ' ').split(' '),\n    field, f, component, items;\n\n  for (field in FIELDS) {\n    f = FIELDS[field];\n    component = components[f[0]];\n    if (component && component !== '*' && component !== '?') {\n      // need to sort so that any #'s come last, otherwise\n      // schedule clones to handle # won't contain all of the\n      // other constraints\n      items = component.split(',').sort(itemSorter);\n      var i, length = items.length;\n      for (i = 0; i < length; i++) {\n        parse(items[i], schedule, field, f[1], f[2], f[3]);\n      }\n    }\n  }\n\n  return schedule;\n}\n\n/**\n * Make cron expression parsable.\n *\n * @param {String} expr: The cron expression to prepare\n */\nfunction prepareExpr(expr) {\n  var prepared = expr.toUpperCase();\n  return REPLACEMENTS[prepared] || prepared;\n}\n\nfunction parseCron(expr, hasSeconds) {\n  var e = prepareExpr(expr);\n  return parseExpr(hasSeconds ? e : '0 ' + e);\n}\n\nexport default parseCron;\n","import parseCron from './parseCron';\n\nconst LOCALE = {\n  ORDINALS: {\n    th: 'th',\n    st: 'st',\n    nd: 'nd',\n    rd: 'rd'\n  },\n  MONTH: [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec'\n  ],\n  DOW: [\n    'Sun',\n    'Mon',\n    'Tue',\n    'Wed',\n    'Thu',\n    'Fri',\n    'Sat'\n  ],\n  'Every': 'Every', // start of expression\n  'and': 'and', // 1, 2, 3 and 15th\n  'every day': 'every day',\n  'minute past the': 'minute past the',\n  'hour': 'hour',\n  'minute': 'minute',\n  'minute of': 'minute of',\n  'minute every hour': 'minute every hour',\n  'on the': 'on the',\n  'of every month': 'of every month',\n  'and every': 'and every',\n  'on': 'on', // on sun, mon\n  'in': 'in' // in jan, apr\n};\n\n/**\n * Given a cronspec, return the human-readable string.\n * @param {string} cronspec\n * @param sixth\n * @param {Object=} locale\n */\nfunction cronToText(cronspec, sixth, locale = LOCALE) {\n  var schedule = parseCron(cronspec, sixth);\n\n  function absFloor(number) {\n    if (number < 0) {\n      return Math.ceil(number);\n    } else {\n      return Math.floor(number);\n    }\n  }\n\n  function toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n      value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n      value = absFloor(coercedNumber);\n    }\n\n    return value;\n  }\n\n  function ordinal(number) {\n    var b = number % 10,\n      output = (toInt(number % 100 / 10) === 1) ? locale.ORDINALS.th :\n        (b === 1) ? locale.ORDINALS.st :\n          (b === 2) ? locale.ORDINALS.nd :\n            (b === 3) ? locale.ORDINALS.rd : locale.ORDINALS.th;\n    return number + output;\n  }\n\n  /**\n   * For an array of numbers, e.g. a list of hours in a schedule,\n   * return a string listing out all of the values (complete with\n   * \"and\" plus ordinal text on the last item).\n   * @param {Number[]} numbers\n   * @returns {string}\n   */\n  function numberList(numbers) {\n    if (numbers.length < 2) {\n      return ordinal(numbers);\n    }\n\n    var lastVal = numbers.pop();\n    return numbers.join(', ') + ` ${locale['and']} ` + ordinal(lastVal);\n  }\n\n  /**\n   * Parse a number into day of week, or a month name;\n   * used in dateList below.\n   * @param {Number|String} value\n   * @param {String} type\n   * @returns {String}\n   */\n  function numberToDateName(value, type) {\n    if (type == 'dow') {\n      return locale.DOW[value - 1];\n    } else if (type == 'mon') {\n      return locale.MONTH[value - 1];\n    }\n  }\n\n  /**\n   * From an array of numbers corresponding to dates (given in type: either\n   * days of the week, or months), return a string listing all the values.\n   * @param {Number[]} numbers\n   * @param {String} type\n   * @returns {String}\n   */\n  function dateList(numbers, type) {\n    if (numbers.length < 2) {\n      return numberToDateName('' + numbers[0], type);\n    }\n\n    var lastVal = '' + numbers.pop();\n    var outputText = '';\n\n    for (var i = 0, value; value = numbers[i]; i++) {\n      if (outputText.length > 0) {\n        outputText += ', ';\n      }\n      outputText += numberToDateName(value, type);\n    }\n    return outputText + ` ${locale['and']} ` + numberToDateName(lastVal, type);\n  }\n\n  /**\n   * Pad to equivalent of sprintf('%02d').\n   * @param {Number} x\n   * @returns {string}\n   */\n  function zeroPad(x) {\n    return (x < 10) ? '0' + x : x;\n  }\n\n  //----------------\n\n  /**\n   * Given a schedule, generate a friendly sentence description.\n   * @param {Object} schedule\n   * @returns {string}\n   */\n  function scheduleToSentence(schedule) {\n    var outputText = locale.Every + ' ';\n\n    if (schedule['h'] && schedule['m'] && schedule['h'].length <= 2 && schedule['m'].length <= 2) {\n      // If there are only one or two specified values for\n      // hour or minute, print them in HH:MM format\n\n      var hm = [];\n      for (var i = 0; i < schedule['h'].length; i++) {\n        for (var j = 0; j < schedule['m'].length; j++) {\n          hm.push(zeroPad(schedule['h'][i]) + ':' + zeroPad(schedule['m'][j]));\n        }\n      }\n      if (hm.length < 2) {\n        outputText = hm[0];\n      } else {\n        var lastVal = hm.pop();\n        outputText = hm.join(', ') + ` ${locale.and} ` + lastVal;\n      }\n      if (!schedule['d'] && !schedule['D']) {\n        outputText += ` ${locale['every day']}`;\n      }\n    } else {\n      // Otherwise, list out every specified hour/minute value.\n\n      if (schedule['h']) { // runs only at specific hours\n        if (schedule['m']) { // and only at specific minutes\n          outputText += numberList(schedule['m']) + ` ${locale['minute past the']} ` + numberList(schedule['h']) + ` ${locale['hour']}`;\n        } else { // specific hours, but every minute\n          outputText += `${locale['minute of']} ` + numberList(schedule['h']) + ` ${locale['hour']}`;\n        }\n      } else if (schedule['m']) { // every hour, but specific minutes\n        outputText += numberList(schedule['m']) + ` ${locale['minute every hour']}`;\n      } else { // cronspec has \"*\" for both hour and minute\n        outputText += locale['minute'];\n      }\n    }\n\n    if (schedule['D']) { // runs only on specific day(s) of month\n      outputText += (locale['on the'] ? ` ${locale['on the']} ` : ' ') + numberList(schedule['D']);\n      if (!schedule['M']) {\n        outputText += ` ${locale['of every month']}`;\n      }\n    }\n\n    if (schedule['d']) { // runs only on specific day(s) of week\n      if (schedule['D']) {\n        // if both day fields are specified, cron uses both; superuser.com/a/348372\n        outputText += ` ${locale['and every']} `;\n      } else {\n        outputText += ` ${locale['on']} `;\n      }\n      outputText += dateList(schedule['d'], 'dow');\n    }\n\n    if (schedule['M']) {\n      // runs only in specific months; put this output last\n      outputText += ` ${locale['in']} ` + dateList(schedule['M'], 'mon');\n    }\n\n    return outputText;\n  }\n\n  return scheduleToSentence(schedule.schedules[0]);\n}\n\nexport default cronToText;\n"],"sourceRoot":"/source/"}